<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音频转录可视化工具</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f4f4f4; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        .upload-section, .player-section, .config-section, .transcript-section, .cache-section { margin-bottom: 20px; }
        audio { width: 100%; margin-top: 10px; }
        .transcript { height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; background: #fff; }
        /* 仅在悬浮时高亮 */
        .highlight { background-color: transparent; cursor: pointer; transition: background-color .15s ease; }
        .highlight:hover { background-color: yellow; }
        /* 灰白间隔行背景 */
        .transcript > div:nth-child(odd) { background: #ffffff; }
        .transcript > div:nth-child(even) { background: #f6f6f6; }
        .muted { color: #888; font-size: 12px; }
        .progress { width: 100%; height: 12px; background: #eee; border-radius: 6px; overflow: hidden; margin-top: 8px; }
        .progress-bar { height: 100%; width: 0%; background: linear-gradient(90deg, #4caf50, #8bc34a); transition: width 0.2s ease; }
        .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
        .btn { padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; background: #fafafa; cursor: pointer; }
        .btn:active { transform: translateY(1px); }
        .badge { display: inline-block; min-width: 38px; padding: 2px 6px; border-radius: 4px; background: #eee; text-align: center; }
        label.inline { display: inline-flex; gap: 6px; align-items: center; }
    </style>
</head>
<body>
    <div class="container">
        <h1>音频转录可视化工具</h1>
        
        <div class="upload-section">
            <h2>上传音频文件</h2>
            <input type="file" id="audioFile" accept="audio/*">
            <button class="btn" onclick="loadAudio()">加载音频</button>
        </div>

        <div class="player-section">
            <h2>音频播放器</h2>
            <audio id="audioPlayer" controls></audio>
            <!-- 播放控制：区段循环、快进快退、步长调节 -->
            <div class="row" style="margin-top:8px">
                <label class="inline"><input type="checkbox" id="loopToggle"> 区段循环</label>
                <span id="loopInfo" class="muted">循环区段：-- 秒</span>
            </div>
            <div class="row">
                <button class="btn" onclick="rewind()">⏪ 快退</button>
                <button class="btn" onclick="forward()">快进 ⏩</button>
                <span class="muted">步长: <span id="skipStepVal" class="badge">15</span>s</span>
                <button class="btn" onclick="adjustSkipStep(-5)">-5s</button>
                <button class="btn" onclick="adjustSkipStep(5)">+5s</button>
            </div>
        </div>

        <div class="config-section">
            <h2>分割配置</h2>
            <div class="row">
                <label for="startTime">开始（秒）:</label>
                <input type="number" id="startTime" value="0" min="0" step="0.1" style="width:100px">
                <label for="endTime">结束（秒）:</label>
                <input type="number" id="endTime" value="60" min="1" step="0.1" style="width:100px">
                <label for="segmentDuration">单位时长（秒）:</label>
                <input type="number" id="segmentDuration" value="60" min="1" max="180" step="0.1" style="width:120px" title="最大180秒">
                <button class="btn" onclick="setEndToMax()">对齐到音频末尾</button>
                <button class="btn" onclick="startTranscription()">开始转录</button>
            </div>
            <div class="row">
                <div id="segInfo" class="muted"></div>
            </div>
            <div class="progress" title="分割/转录进度">
                <div id="progressBar" class="progress-bar"></div>
            </div>
        </div>

        <div class="transcript-section">
            <h2>转录文本</h2>
            <div id="transcript" class="transcript"></div>
        </div>

        <div class="cache-section">
            <h2>缓存</h2>
            <div class="row">
                <div id="cacheInfo" class="muted">缓存大小：--</div>
                <button class="btn" onclick="clearCache()">清理缓存</button>
            </div>
        </div>
    </div>

    <script>
        let audioPlayer = document.getElementById('audioPlayer');
        let transcriptDiv = document.getElementById('transcript');
        let segInfo = document.getElementById('segInfo');
        let progressBar = document.getElementById('progressBar');
        let cacheInfo = document.getElementById('cacheInfo');
        let audioDuration = null; // 真实音频时长（秒）
        // 循环与快进快退参数
        let loopEnabled = false;
        let loopStart = null;
        let loopEnd = null;
        let skipStep = 15; // 默认步长15秒
        const skipStepVal = document.getElementById('skipStepVal');
        const loopToggle = document.getElementById('loopToggle');
        const loopInfo = document.getElementById('loopInfo');
        
        // 页面加载时自动检查并加载默认音频文件，并获取音频元数据与缓存信息
        window.addEventListener('load', function() {
            checkAndLoadDefaultAudio();
            refreshAudioMetadata();
            refreshCacheInfo();
            updateSkipStepUI();
        });
        
        loopToggle.addEventListener('change', (e) => {
            loopEnabled = e.target.checked;
            // 若开启循环且已有区段，立即跳转到区段起点
            if (loopEnabled && loopStart != null && loopEnd != null) {
                audioPlayer.currentTime = loopStart;
                audioPlayer.play();
            }
        });

        audioPlayer.addEventListener('timeupdate', () => {
            if (loopEnabled && loopStart != null && loopEnd != null) {
                // 留出一个很小的缓冲，避免时间update误差
                if (audioPlayer.currentTime >= loopEnd - 0.05) {
                    audioPlayer.currentTime = loopStart;
                    // 继续播放形成循环
                    if (audioPlayer.paused) audioPlayer.play();
                }
            }
        });

        function updateSkipStepUI() { skipStepVal.textContent = String(skipStep); }
        function adjustSkipStep(delta) {
            skipStep = Math.max(5, skipStep + delta); // 最小5秒
            updateSkipStepUI();
        }
        function rewind() {
            const cur = audioPlayer.currentTime || 0;
            const target = Math.max(0, cur - skipStep);
            audioPlayer.currentTime = target;
        }
        function forward() {
            const dur = audioDuration || audioPlayer.duration || Infinity;
            const cur = audioPlayer.currentTime || 0;
            const target = Math.min(dur, cur + skipStep);
            audioPlayer.currentTime = target;
        }

        function refreshAudioMetadata() {
            fetch('/audio/metadata').then(r => r.json()).then(data => {
                if (data.exists && typeof data.duration === 'number') {
                    audioDuration = data.duration;
                    const endInput = document.getElementById('endTime');
                    if (parseFloat(endInput.value) > audioDuration) {
                        endInput.value = Math.max(1, Math.floor(audioDuration));
                        alert('已根据真实音频时长自动限制结束时间');
                    }
                }
            }).catch(() => {});
        }
        
        function refreshCacheInfo() {
            fetch('/cache/info').then(r => r.json()).then(data => {
                const size = data.size_bytes || 0;
                cacheInfo.textContent = '缓存大小：' + humanFileSize(size);
            }).catch(() => { cacheInfo.textContent = '缓存大小：--'; });
        }
        
        function clearCache() {
            fetch('/cache/clear', { method: 'POST' }).then(r => r.json()).then(_ => {
                refreshCacheInfo();
            });
        }

        function checkAndLoadDefaultAudio() {
            fetch('/uploads/output_clip.wav', { method: 'HEAD' })
                .then(response => {
                    if (response.ok) {
                        audioPlayer.src = '/uploads/output_clip.wav';
                        audioPlayer.load();
                        console.log('已自动加载默认音频文件: output_clip.wav');
                    }
                })
                .catch(error => {
                    console.log('默认音频文件不存在，等待用户上传');
                });
        }

        function loadAudio() {
            const fileInput = document.getElementById('audioFile');
            const file = fileInput.files[0];
            if (file) {
                const formData = new FormData();
                formData.append('file', file);
                fetch('/upload', { method: 'POST', body: formData })
                .then(response => response.json())
                .then(data => {
                    audioPlayer.src = data.url; audioPlayer.load();
                    setTimeout(() => { refreshAudioMetadata(); }, 200);
                })
                .catch(error => console.error('Error:', error));
            }
        }

        function getParams() {
            const startTime = parseFloat(document.getElementById('startTime').value);
            const endTime = parseFloat(document.getElementById('endTime').value);
            const segmentDuration = parseFloat(document.getElementById('segmentDuration').value);
            return { startTime, endTime, segmentDuration };
        }

        function validateParams() {
            const { startTime, endTime, segmentDuration } = getParams();
            if (isNaN(startTime) || isNaN(endTime) || isNaN(segmentDuration)) { alert('请输入有效的数字参数'); return false; }
            if (endTime <= startTime) { alert('结束时间必须大于开始时间'); return false; }
            if (segmentDuration <= 0) { alert('分割单位时长必须大于0'); return false; }
            if (segmentDuration > 180) { alert('分割单位时长不能超过 180 秒'); return false; }
            const windowLen = endTime - startTime;
            if (segmentDuration > windowLen) { alert('分割单位时长不能超过(结束时间-开始时间)'); return false; }
            if (audioDuration && endTime > audioDuration) {
                alert('结束时间不能超过音频总时长，已自动调整');
                document.getElementById('endTime').value = Math.max(1, Math.floor(audioDuration));
                return false;
            }
            return true;
        }

        function startTranscription() {
            if (!validateParams()) return;
            const { startTime, endTime, segmentDuration } = getParams();
            transcriptDiv.innerHTML = '';
            segInfo.textContent = '';
            setProgress(0);

            const url = new URL('/transcribe/stream', window.location.origin);
            url.searchParams.set('start_time', startTime);
            url.searchParams.set('end_time', endTime);
            url.searchParams.set('segment_duration', segmentDuration);

            const es = new EventSource(url.toString());

            es.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    if (data.type === 'segments') {
                        segInfo.textContent = `将分割为 ${data.segments_count} 个片段${data.cached ? '（命中缓存）' : ''}`;
                    } else if (data.type === 'partial') {
                        upsertTranscript(data.timestamp, data.text);
                    } else if (data.type === 'segment_done') {
                        upsertTranscript(data.timestamp, data.text, true);
                    } else if (data.type === 'progress') {
                        setProgress(data.percent || 0);
                    } else if (data.type === 'done') {
                        setProgress(100);
                        es.close();
                        refreshCacheInfo();
                    } else if (data.type === 'error') {
                        console.error('SSE错误:', data.message);
                    }
                } catch (e) {
                    console.error('解析SSE数据失败:', e);
                }
            };

            es.onerror = (e) => {
                console.error('SSE连接出错:', e);
                es.close();
            };
        }

        function setEndToMax() {
            const endInput = document.getElementById('endTime');
            if (typeof audioDuration === 'number' && !isNaN(audioDuration)) {
                endInput.value = Math.max(1, Math.floor(audioDuration));
            } else {
                // 若未知音频时长，尝试刷新一次元数据后再设置
                refreshAudioMetadata();
                setTimeout(() => {
                    if (typeof audioDuration === 'number' && !isNaN(audioDuration)) {
                        endInput.value = Math.max(1, Math.floor(audioDuration));
                    } else {
                        alert('暂无法获取音频总时长，请先加载音频');
                    }
                }, 250);
            }
        }

        function setProgress(pct) {
            progressBar.style.width = Math.max(0, Math.min(100, pct)) + '%';
        }

        function upsertTranscript(timestamp, text, finalized=false) {
            const id = `ts-${timestamp}`;
            let el = document.getElementById(id);
            const html = `<span class="highlight" data-timestamp="${timestamp}">${escapeHtml(text)}</span>`;
            if (!el) { el = document.createElement('div'); el.id = id; el.innerHTML = html; transcriptDiv.appendChild(el); }
            else { el.innerHTML = html; }
        }

        // 点击转录文本：跳转播放 + 更新循环区段
        transcriptDiv.addEventListener('click', function(e) {
            if (e.target.classList.contains('highlight')) {
                const ts = e.target.getAttribute('data-timestamp');
                if (ts && audioPlayer.src) {
                    const startTs = parseFloat(ts);
                    // 结束时间：采用“当前段起点 + 单位时长（segmentDuration）”的规则
                    const segDurInput = document.getElementById('segmentDuration');
                    const segDur = Math.max(1, parseFloat(segDurInput.value) || 0);
                    let endTs = startTs + segDur;

                    // 约束结束时间到配置的 endTime 和音频总时长之内（若可用）
                    const p = getParams();
                    if (typeof p.endTime === 'number' && !isNaN(p.endTime)) {
                        endTs = Math.min(endTs, p.endTime);
                    }
                    if (typeof audioDuration === 'number' && !isNaN(audioDuration)) {
                        endTs = Math.min(endTs, audioDuration);
                    } else if (!isFinite(audioPlayer.duration)) {
                        // 兜底，至少保证区段 > 0 秒
                        endTs = Math.max(endTs, startTs + 1);
                    }

                    loopStart = startTs;
                    loopEnd = Math.max(loopStart, endTs);
                    // 显示为“起始~结束秒”，以整数秒呈现
                    const s = Math.round(loopStart);
                    const eSec = Math.round(loopEnd);
                    loopInfo.textContent = `循环区段：${s}~${eSec}秒`;

                    audioPlayer.currentTime = loopStart;
                    audioPlayer.play();
                }
            }
        });

        function formatTranscriptWithTimestamps(transcriptText) {
            return transcriptText.replace(/\[(\d+\.?\d*)\]([^\[]+)/g, '<span class="highlight" data-timestamp="$1">$2</span>');
        }

        function escapeHtml(text) {
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return String(text).replace(/[&<>"']/g, m => map[m]);
        }

        function humanFileSize(bytes) {
            const thresh = 1024;
            if (Math.abs(bytes) < thresh) return bytes + ' B';
            const units = ['KB','MB','GB','TB','PB','EB','ZB','YB'];
            let u = -1;
            do { bytes /= thresh; ++u; } while (Math.abs(bytes) >= thresh && u < units.length - 1);
            return bytes.toFixed(1)+' '+units[u];
        }
    </script>
</body>
</html>